// Package archive provides the logic for Gatecheck Bundles
package archive

import (
	"archive/tar"
	"bytes"
	"compress/gzip"
	"crypto/sha256"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"strings"
	"time"

	gce "github.com/gatecheckdev/gatecheck/pkg/encoding"
)

// FileType in plain text
const FileType = "Gatecheck Bundle"

// BundleVersion the version support by this archive format
const BundleVersion = "1"

// ManifestFilename the file name to be used as a default
const ManifestFilename = "gatecheck-manifest.json"

// DefaultBundleFilename the bundle name to be used as a default
const DefaultBundleFilename = "gatecheck-bundle.tar.gz"

// Manifest is created and loaded into a bundle which contains information on the files
type Manifest struct {
	Created time.Time                 `json:"createdAt"`
	Version string                    `json:"version"`
	Files   map[string]fileDescriptor `json:"files"`
}

type fileDescriptor struct {
	Added      time.Time         `json:"addedAt"`
	Properties map[string]string `json:"properties"`
	Digest     string            `json:"digest"`
}

// Bundle uses tar and gzip to collect reports and files into a single file
type Bundle struct {
	content  map[string][]byte
	manifest Manifest
}

// NewBundle ...
func NewBundle() *Bundle {
	return &Bundle{
		content:  make(map[string][]byte),
		manifest: Manifest{Created: time.Now(), Version: BundleVersion, Files: make(map[string]fileDescriptor)},
	}
}

// Manifest generated by the bundle
func (b *Bundle) Manifest() Manifest {
	return b.manifest
}

// WriteFileTo Used to write files inside of the bundle to a writer
func (b *Bundle) WriteFileTo(w io.Writer, fileLabel string) (int64, error) {
	fileBytes, ok := b.content[fileLabel]
	if !ok {
		return 0, fmt.Errorf("%w: Label '%s' not found in bundle", gce.ErrIO, fileLabel)
	}
	return bytes.NewReader(fileBytes).WriteTo(w)
}

// FileSize get the file size for a specific label
func (b *Bundle) FileSize(fileLabel string) int {
	fileBytes, ok := b.content[fileLabel]
	if !ok {
		return 0
	}
	return len(fileBytes)
}

// AddFrom reads files into the bundle
func (b *Bundle) AddFrom(r io.Reader, label string, properties map[string]string) error {
	hasher := sha256.New()
	p, err := io.ReadAll(r)
	_, _ = bytes.NewReader(p).WriteTo(hasher)
	if err != nil {
		return fmt.Errorf("%w: %v", gce.ErrIO, err)
	}
	digest := fmt.Sprintf("%x", hasher.Sum(nil))

	b.manifest.Files[label] = fileDescriptor{Added: time.Now(), Properties: properties, Digest: digest}

	b.content[label] = p
	return nil
}

// Delete will remove files from the bundle by label
func (b *Bundle) Delete(label string) {
	delete(b.content, label)
	delete(b.manifest.Files, label)
}

func TarGzipBundle(dst io.Writer, bundle *Bundle) (int64, error) {
	if bundle == nil {
		return 0, errors.New("cannot write nil bundle")
	}
	tarballBuffer := new(bytes.Buffer)
	tarWriter := tar.NewWriter(tarballBuffer)
	manifestBytes, _ := json.Marshal(bundle.manifest)
	_ = bundle.AddFrom(bytes.NewReader(manifestBytes), "gatecheck-manifest.json", nil)

	for label, data := range bundle.content {
		// Using bytes.Buffer so IO errors are unlikely
		_ = tarWriter.WriteHeader(&tar.Header{Name: label, Size: int64(len(data)), Mode: int64(os.FileMode(0o666))})
		_, _ = bytes.NewReader(data).WriteTo(tarWriter)
	}
	tarWriter.Close()

	bundle.Delete(ManifestFilename)
	gzipWriter := gzip.NewWriter(dst)
	_, _ = tarballBuffer.WriteTo(gzipWriter)
	gzipWriter.Close()

	return 0, nil
}

func UntarGzipBundle(src io.Reader) (*Bundle, error) {
	gzipReader, err := gzip.NewReader(src)
	if err != nil {
		return nil, err
	}
	tarReader := tar.NewReader(gzipReader)

	bundle := new(Bundle)
	bundle.content = make(map[string][]byte)
	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}

		if header.Typeflag != tar.TypeReg {
			return nil, errors.New("Gatecheck Bundle only supports regular files in a flat directory structure")
		}
		fileBytes, _ := io.ReadAll(tarReader)
		bundle.content[header.Name] = fileBytes
	}
	manifest := new(Manifest)
	manifestBytes, ok := bundle.content[ManifestFilename]
	if !ok {
		return nil, errors.New("Gatecheck Bundle manifest not found")
	}
	if err := json.Unmarshal(manifestBytes, manifest); err != nil {
		return nil, fmt.Errorf("gatecheck manifest decoding: %w", err)
	}
	bundle.manifest = *manifest
	bundle.Delete(ManifestFilename)

	return bundle, nil
}

// BundleEncoder is used to write bundles to io.Writer
type BundleEncoder struct {
	w io.Writer
}

// NewBundleEncoder ...
//
// Deprecated: Use TarGzipBundle function instead
func NewBundleEncoder(w io.Writer) *BundleEncoder {
	strings.NewReader("abc")
	return &BundleEncoder{w: w}
}

// Encode to the internal writer
//
// Deprecated: Use TarGzipBundle function instead
func (b *BundleEncoder) Encode(bundle *Bundle) error {
	if bundle == nil {
		return fmt.Errorf("%w: bundle is nil", gce.ErrEncoding)
	}
	tarballBuffer := new(bytes.Buffer)
	tarWriter := tar.NewWriter(tarballBuffer)
	manifestBytes, _ := json.Marshal(bundle.manifest)
	_ = bundle.AddFrom(bytes.NewReader(manifestBytes), "gatecheck-manifest.json", nil)

	for label, data := range bundle.content {
		// Using bytes.Buffer so IO errors are unlikely
		_ = tarWriter.WriteHeader(&tar.Header{Name: label, Size: int64(len(data)), Mode: int64(os.FileMode(0o666))})
		_, _ = bytes.NewReader(data).WriteTo(tarWriter)
	}
	tarWriter.Close()

	bundle.Delete(ManifestFilename)
	gzipWriter := gzip.NewWriter(b.w)
	_, _ = tarballBuffer.WriteTo(gzipWriter)
	gzipWriter.Close()

	return nil
}

// BundleDecoder is used to decode bundle objects from a reader
//
// Deprecated: Use TarGzipBundle function instead
type BundleDecoder struct {
	bytes.Buffer
}

// NewBundleDecoder ...
//
// Deprecated: Use TarGzipBundle function instead
func NewBundleDecoder() *BundleDecoder {
	return new(BundleDecoder)
}

// DecodeFrom a bundle object
//
// Deprecated: Use TarGzipBundle function instead
func (d *BundleDecoder) DecodeFrom(r io.Reader) (any, error) {
	_, err := d.ReadFrom(r)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", gce.ErrIO, err)
	}

	return d.Decode()
}

// Decode will gunzip and untar the bundle into an object, follows generic decoder pattern
//
// Deprecated: Use TarGzipBundle function instead
func (d *BundleDecoder) Decode() (any, error) {
	gzipReader, err := gzip.NewReader(d)
	if err != nil {
		return nil, fmt.Errorf("%w: gzip decode: %v", gce.ErrEncoding, err)
	}
	tarReader := tar.NewReader(gzipReader)

	bundle := new(Bundle)
	bundle.content = make(map[string][]byte)
	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("%w: tar decode: %v", gce.ErrEncoding, err)
		}

		if header.Typeflag != tar.TypeReg {
			return nil, fmt.Errorf("%w: Gatecheck Bundle only supports regular files in a flat directory structure", gce.ErrEncoding)
		}
		fileBytes, _ := io.ReadAll(tarReader)
		bundle.content[header.Name] = fileBytes
	}
	manifest := new(Manifest)
	manifestBytes, ok := bundle.content[ManifestFilename]
	if !ok {
		return nil, fmt.Errorf("%w: Gatecheck Bundle manifest not found", gce.ErrEncoding)
	}
	if err := json.Unmarshal(manifestBytes, manifest); err != nil {
		return nil, fmt.Errorf("%w: gatecheck manifest decoding: %v", gce.ErrEncoding, err)
	}
	bundle.manifest = *manifest
	bundle.Delete(ManifestFilename)

	return bundle, nil
}

// FileType in plain text
//
// Deprecated: Use TarGzipBundle function instead
func (d *BundleDecoder) FileType() string {
	return FileType
}
